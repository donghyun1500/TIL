###알고리즘 배우기 둘째날!!###

<참고>

##1. Swap하는 방법. a, b = b, a 라고 작성하면 됨!

##2.스택 이라는 자료 구조에서 제공하는 기능!

push(data) : 맨 앞에 데이터 넣기

pop() : 맨 앞의 데이터 뽑기

peek() : 맨 앞의 데이터 보기

isEmpty(): 스택이 비었는지 안 비었는지 여부 반환해주기

###2.퀄 이라는 자료 구조에서 제공하는 기능!!

enqueue(data) : 맨 뒤에 데이터 추가하기 

dequeue() : 맨 앞의 데이터 뽑기

peek() : 맨 앞의 데이터 보기

isEmpty(): 큐가 비었는지 안 비었는지 여부 반환해주기

##3. 해쉬에서 

딕셔너리에서 쓰이는 함수들
put(key, value) : key 에 value 저장하기

     def put(self, key, value):
        
        *index = hash(key) % len(self.items)*
        
        self.items[index] = value
        
이 값의 인덱스에 value 담기!
        

get(key) : key 에 해당하는 value 가져오기

     def get(self, key):
        
        index = hash(key) % len(self.items)
        
        *return self.items[index]*
        
해당 아이템을 가진 items의 원소 반환해주기!



첫번째, 버블정렬이란?

첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, 

… 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬하는 방식!

선택정렬?

가장 작은 값을 선택해 알맞은 위치로 옮기는 방식!

삽입정렬?

고른 값을 알만은 위치로 삽입하여 정렬하는 방식!

선택 정렬은 현재 데이터의 상태와 상관없이 항상 비교하고 위치를 바꾸지만,

삽입 정렬은 필요할 때만 위치를 변경하므로 더 효율적인 방식!

병합정렬? merge?

병합 정렬은 배열의 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘!

병합정렬? mergeSort?

분할 정복은 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략!

문제를 쪼개서 일부분들을 해결하다보면 전체가 해결 됨!

이를 분할 정복, Divide and Conquer 라고 함!

*재귀적인 함수코드와 비슷하여 꼭 재귀함수에 필수 조건인 탈수 조건도 만들어줘야 함.*


두번째, 스택이란??

스택은 데이터를 임시 저장할 때 사용하는 자료구조로 데이터의 입력과 출력 순서는 후입선출(LIFO) 방식임.


큐란?

스택과 같은 데이터를 임시 저장하는 자료구조! 하지만 스택과 다르게 선입선출(FIFO) 방식임.

하지만 스택과 다르게 끝과 시작의 노드를 전부 가지고 있어야 하므로,

self.head 와 self.tail 을 가지고 시작함!


*둘 다 링크드리스트와 아주 유사함!*


세번째, 해쉬란?

해쉬 테이블이란? 

"키" 와 "데이터"를 저장함으로써 즉각적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 자료구조.

해쉬 함수(Hash Function)란?

임의의 길이를 갖는 메시지를 입력하여 고정된 길이의 해쉬값을 출력하는 함수이다

충돌이란?

같은 어레이의 인덱스로 매핑이 되어서 데이터를 덮어 써버리는 결과가 발생하면

이를 충돌(collision)이 발생했다고 한다. 

충돌을 해결하는 첫번쨰 방법

1.체이닝(Chaining) : 충돌을 해결하는 첫번째 방법은 바로 링크드 리스트를 사용하는 방식입니다.
                     이 방식을 연결지어서 해결함.
                     
2.개방주소법(Open Addressing): 충돌을 해결하는 두 번째 방법은 배열의 다음 남는 공간에 넣는 것!

이건 안배워서 잘 모름!!!!!


네번째, 트리

큐(Queue), 스택(Stack) 은 자료구조에서 선형 구조(자료를 구성하고 있는 데이터들이 순차적으로 나열시킨 형태)인데 반해 트리는 비선형 구조임.

선형구조는 자료를 저장하고 꺼내는 것에 초점이 맞춰져 있고, 비선형구조는 표현에 초점이 맞춰져 있습니다.

!!트리에서 나오는 용어 정리!!
Node: 트리에서 데이터를 저장하는 기본 요소 

Root Node: 트리 맨 위에 있는 노드

Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄

Parent Node: 어떤 노드의 상위 레벨에 연결된 노드

Child Node: 어떤 노드의 하위 레벨에 연결된 노드

Leaf Node(Terminal Node): Child Node가 하나도 없는 노드

Sibling: 동일한 Parent Node를 가진 노드

Depth: 트리에서 Node가 가질 수 있는 최대 Level


![image](https://user-images.githubusercontent.com/85468215/121780788-d57e4d00-cbdc-11eb-8fa9-6d1a6bc5e1a2.png)

참고하셈!!


이진트리(Binary Tree)..

각 노드가 최대 두 개의 자식을 가짐.


완전 이진트리(Complete Binary Tree)..

노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입해야 함.








아직은 너무 많이 어렵다.. 과연 내가 잘할수 있을 것인가..의문이 계속해서 들지만 열심히 해봐야겠다...

그리고 알고리즘을 배우면서 드는 생각이 개념도 중요하지만 

문제의 핵심 개념을 이해해서 하나하나 그걸 구현할수 있게 문법이나 파이썬 언어로 표현할수 있어야 하는데 난 아직 못하겠다..ㅠ

그리고 만약의 알고리즘을 완성하면 시간복잡도를 분석해보자!!!!(아직은 왜 하는지 모르겟다..)
